
<p>假设我们有<script type="math/tex">m</script>个<script type="math/tex">n</script>维数据点，<script type="math/tex">\{x^{(1)},x^{(2)},...,x^{(m)}\}</script></p>

<p>因为一些原因，现在需要对其进行有损压缩。</p>

<p>对每个<script type="math/tex">n</script>维数据点<script type="math/tex">x^{(i)}</script>，在<script type="math/tex">l</script>维空间<script type="math/tex">(l \leq n)</script>中找到一个数据点<script type="math/tex">c^{(i)}</script>作为其压缩结果</p>

<p>将<script type="math/tex">x</script>压缩为<script type="math/tex">c</script>的过程称为编码，从<script type="math/tex">c</script>重新构造出<script type="math/tex">x</script>的过程称为解码</p>

<p>因为两个过程实际上都能用矩阵乘法表示，我们将解码过程表示为</p>

<p>\begin{align}
x=Dc
\end{align}</p>

<p>上式中，<script type="math/tex">D</script>是一个<script type="math/tex">n</script>行<script type="math/tex">l</script>列的矩阵</p>

<ul>
  <li>由于放大<script type="math/tex">D</script>的值，缩小<script type="math/tex">c</script>的值，上式仍然成立，为了使结果唯一，令<script type="math/tex">D</script>的所有列向量均为单位向量</li>
  <li>为了使解码空间（<script type="math/tex">D</script>的列空间）能够覆盖整个<script type="math/tex">n</script>维空间，令<script type="math/tex">D</script>的<script type="math/tex">n</script>个列向量互相正交</li>
</ul>

<p>上两个约束的公式化表述是<script type="math/tex">D^TD=I_l</script></p>

<p>由解码过程不难推出编码过程就是</p>

<p>\begin{align}
c=D^Tx
\end{align}</p>

<p>经过编码再解码的结果<script type="math/tex">r(x)=DD^Tx</script></p>

<p>我们的优化目标就是最小化<script type="math/tex">r(x)</script>与<script type="math/tex">x</script>的差距，最优值<script type="math/tex">D^*</script>的公式化表述如下</p>

<p>\begin{align}
&amp; D^* = \mathop{argmin}_D\sum_{i}||x^{(i)}-DD^Tx^{(i)}||^2_2 \\
&amp; s.t. \quad D^TD=I_l
\end{align}</p>

<p><script type="math/tex">X</script>为一个<script type="math/tex">m</script>行<script type="math/tex">n</script>列的矩阵，第<script type="math/tex">i</script>个行向量表示<script type="math/tex">(x^{(i)})^T</script></p>

<p>使用<script type="math/tex">X</script>，式子可化简为</p>

<p>\begin{align}
&amp; D^* = \mathop{argmin}_D||X-XDD^T||^2_F \\
&amp; s.t. \quad D^TD=I_l
\end{align}</p>

<p>F表示Frobenius范数</p>

<p>继续化简</p>

<p>\begin{align}
D^* &amp;= \mathop{argmin}_D||X-XDD^T||^2_F \\
&amp;= \mathop{argmin}_DTr\left((X-XDD^T)^T(X-XDD^T)\right) \\
&amp;= \mathop{argmin}_DTr\left((X^T-DD^TX^T)(X-XDD^T)\right) \\
&amp;= \mathop{argmin}_DTr\left(  X^TX-X^TXDD^T-DD^TX^TX+DD^TX^TXDD^T \right) \\
&amp;= \mathop{argmin}_DTr\left(  -X^TXDD^T-DD^TX^TX+DD^TX^TXDD^T \right) \\
&amp;= \mathop{argmin}_D  -Tr(X^TXDD^T)-Tr(DD^TX^TX)+Tr(DD^TX^TXDD^T)  \\
&amp;= \mathop{argmin}_D  -2Tr(X^TXDD^T)+Tr(X^TXDD^TDD^T)  \\
&amp;= \mathop{argmin}_D  -2Tr(X^TXDD^T)+Tr(X^TXDD^T)  \\
&amp;= \mathop{argmin}_D  -Tr(X^TXDD^T)  \\
&amp;= \mathop{argmax}_D  Tr(D^TX^TXD)  \\
\end{align}</p>

<p>于是，优化目标变为</p>

<p>\begin{align}
&amp; D^* = \mathop{argmax}_D  Tr(D^TX^TXD) \\
&amp; s.t. \quad D^TD=I_l
\end{align}</p>

<p>将<script type="math/tex">X^TX</script>特征分解，有</p>

<p>\begin{align}
X^TX= V \Lambda V^{-1}
\end{align}</p>

<p>\begin{align}
V &amp;= \begin{bmatrix} v_1 &amp; v_2 &amp; … &amp; v_n \end{bmatrix} \\
\Lambda &amp;=
\begin{bmatrix}
\lambda_1 &amp; 0 &amp; … &amp; 0 \\
0 &amp; \lambda_2 &amp; … &amp; 0 \\
… &amp; … &amp; … &amp; … \\
0 &amp; 0 &amp; 0 &amp; \lambda_n
\end{bmatrix}
\end{align}</p>

<p><script type="math/tex">v_i</script>表示特征向量，且保证是单位向量，此外<script type="math/tex">\lambda_1 \geq \lambda_2 \geq ... \geq \lambda_n</script></p>

<p>优化目标变为</p>

<p>\begin{align}
&amp; D^* = \mathop{argmax}_D  Tr(D^TV\Lambda V^{-1}D) \\
&amp; s.t. \quad D^TD=I_l
\end{align}</p>

<p>最优解可直接得到</p>

<p>\begin{align}
D = \begin{bmatrix} v_1 &amp; v_2 &amp; … &amp; v_l \end{bmatrix}
\end{align}</p>
